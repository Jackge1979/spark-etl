package com.yxt.bigdata.etl.connector.rdbms.writer

import com.typesafe.config.Config
import org.apache.spark.sql.DataFrame
import org.apache.spark.sql.execution.datasources.jdbc.JdbcUtils.savePartition
import org.apache.spark.sql.jdbc.JdbcDialects

import com.yxt.bigdata.etl.connector.rdbms.common.DBUtil
import com.yxt.bigdata.etl.connector.base.ETLWriter


class RdbWriter(conf: Config) extends DBUtil(conf) with ETLWriter with Serializable {
  val tableName: String = conf.getString(Key.TABLE_NAME)

  val columns: Array[String] = {
    val cols = conf.getString(Key.COLUMNS).toLowerCase
    if (!"*".equals(cols)) cols.split(",")
    else getAllColumns(tableName)
  }

  private val batchSize: Int = if (conf.hasPath(Key.BATCH_SIZE)) conf.getInt(Key.BATCH_SIZE) else Constant.DEFAULT_BATCH_SIZE

  private val writeMode: String = {
    val customWriteMode = conf.getString("writeMode").trim.toLowerCase
    val isWriteModeLegal = customWriteMode.equals("insert") || customWriteMode.equals("replace")
    if (!isWriteModeLegal)
      throw new Exception(s"您所配置的 writeMode: $customWriteMode 错误。因为目前仅支持replace或insert方式，请检查您的配置并作出修改。")

    customWriteMode.toUpperCase
  }

  override def saveTable(dataFrame: DataFrame): Unit = {
    val writeSql = getWriteRecordSql(columns, "replace")
    val rddSchema = dataFrame.schema
    val dialect = JdbcDialects.get(jdbcUrl)
    val isolationLevel = 0

    dataFrame.rdd.foreachPartition(iterator =>
      savePartition(getConnection, tableName, iterator, rddSchema, writeSql, batchSize, dialect, isolationLevel)
    )
  }

  private def getWriteRecordSql(columns: Array[String], writeMode: String): String = {
    val columnsHolder = columns.mkString(",")
    val valuesHolder = 0.until(columns.length).map(_ => "?").mkString(",")

    if (writeMode == "insert") {
      val onDuplicateKeyUpdateHolder = onDuplicateKeyUpdateString(columns)
      s"""
         |$writeMode INTO $tableName
         |($columnsHolder)
         |VALUES($valuesHolder)
         |$onDuplicateKeyUpdateHolder
     """.stripMargin
    } else if (writeMode == "replace") {
      s"""
         |$writeMode INTO $tableName
         |($columnsHolder)
         |VALUES($valuesHolder)
     """.stripMargin
    } else ""
  }

  private def onDuplicateKeyUpdateString(columns: Array[String]): String = {
    if (columns == null || columns.length < 1) ""
    else {
      val sb = new StringBuilder()
      sb.append("ON DUPLICATE KEY UPDATE")
      var isFirst = true
      for (column <- columns) {
        if (isFirst) isFirst = false
        else sb.append(",")

        sb.append(s" $column=VALUES($column)")
      }

      sb.toString
    }
  }
}
